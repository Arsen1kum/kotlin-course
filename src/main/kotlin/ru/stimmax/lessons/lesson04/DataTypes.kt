package Kotlin.example.ru.stimmax.lessons.lesson04

val myInt: Int = 5 // используем, когда точно знаем, что значение в пределах разрешенных значений (см. справку)
val myFloat: Float = 058F // дробное, невысокой точности, плавающая точка (не подходит для фин-систем), меньше памяти
val myLong: Long = 1_234_567_890L // целые большие числа, сильно за пределами int, (см. справку)
val myShort: Short = 32000 // целые в небольшом диапазоне, почти не используется в нашем контексте, больше экономии памяти
val myByte: Byte  = 120 // дипазон 256
val myDouble: Double = 5.99 // хранит большие числа с плавающей точкой в высоком разрешении

val myBoolean: Boolean = true // булевые значения
val myChar: Char = '%' // хранит _один_ символ в _одиночных_ кавычках, кроме спец
val myText: String = "Hello, my darlings" // двойные кавычки, строка

val myNumbers: Array<Int> = arrayOf(1,2,3) // коллекции создаются в Kotlin спец-методом array - массив. Все элементы внутри коллекций должны быть одного типа
val myStrings: List<String> = listOf("one","two","еркуу") // list - список
val myDoubles: Set<Double> = setOf(23.3,56.7) // set - набор

// словари, пары "ключ"-"значение", типы значений могут быть любые разрешенные
val keysToValues: Map<String, String> = mapOf(
    "Ключ 1 " to "Значение 1",
    "Ключ 2 " to "Значение 2",
)

val keysToValues2: Map<Int, String> = mapOf(
    1 to "Значение 1",
    2 to "Значение 2",
)

// особенности типов данных Kotlin. Примитивов, аналогично Java, нет.
// val i: int = 3

// явное и неявное приведение типов. Можем указывать, можем не указывать тип переменных. В отличие от Java для Kolin
// нужно явно прописывать условие для if'ов. Неявное указание типов - зло. Динамическая типизация в мире

fun main() {
    val r = myInt + myFloat // в этом случае тип приведётся к Float
}

// ещё есть тип Any
val myLongAny: Any = 1_234_567_890L

val myUnit: Unit = Unit // это даже не null, переменная которая содержит _ничего_, нужна для лямбда выражений и возврата именно ничего

fun example(): Nothing {    //Nothing нужна для прерывания работы ошибкой, генерация ошибки, нужна для компилятора
    throw RuntimeException("")
}